#include <stdexcept>

#include "dbtype.h"

//DBType::DBType()
//{
//    dbt = DBT::unknown;
//}

DBType::DBType(etymon::OdbcDbc* dbc)
{
    string dbmsName;
    dbc->getDbmsName(&dbmsName);
    setType(dbmsName);
}

void DBType::setType(const string& dbms)
{
    if (dbms == "PostgreSQL") {
        dbt = DBT::postgresql;
    } else {
        if (dbms == "Redshift") {
            dbt = DBT::redshift;
        } else {
            string err = "Unknown database system: \"";
            err += dbms;
            err += "\"";
            throw runtime_error(err);
        }
    }
}

//const char* DBType::jsonType() const
//{
//    switch (dbt) {
//        case DBT::postgresql:
//            //return "JSON";
//            return "VARCHAR(65535)";
//        case DBT::redshift:
//            return "VARCHAR(65535)";
//        default:
//            return "(unknown)";
//    }
//}

const char* DBType::currentTimestamp() const
{
    switch (dbt) {
        case DBT::postgresql:
            return "CURRENT_TIMESTAMP";
        case DBT::redshift:
            return "SYSDATE";
        default:
            return "(unknown)";
    }
}

//const char* DBType::timestamp0() const
//{
//    switch (dbt) {
//        case DBT::postgresql:
//            return "TIMESTAMP(0)";
//        case DBT::redshift:
//            return "TIMESTAMP";
//        default:
//            return "(unknown)";
//    }
//}

void DBType::autoIncrementSequence(const string& tableName,
        const string& columnName, int64_t start, string* sql) const
{
    *sql = tableName + "_" + columnName + "_" + std::to_string(start) + "_seq";
}

void DBType::autoIncrementBegin(const string& tableName,
        const string& columnName, int64_t start, string* sql) const
{
    string sequence;
    autoIncrementSequence(tableName, columnName, start, &sequence);
    switch (dbt) {
        case DBT::postgresql:
            *sql = "CREATE SEQUENCE " + sequence + " AS BIGINT START " +
                std::to_string(start) + ";";
            return;
        case DBT::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void DBType::autoIncrementType(const string& tableName,
        const string& columnName, int64_t start, string* sql) const
{
    string sequence;
    autoIncrementSequence(tableName, columnName, start, &sequence);
    switch (dbt) {
        case DBT::postgresql:
            *sql = "BIGINT NOT NULL DEFAULT nextval('" + sequence + "')";
            return;
        case DBT::redshift:
            *sql = "BIGINT GENERATED BY DEFAULT AS IDENTITY(" +
                std::to_string(start) + ", 1)";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void DBType::autoIncrementEnd(const string& tableName,
        const string& columnName, int64_t start, string* sql) const
{
    string sequence;
    autoIncrementSequence(tableName, columnName, start, &sequence);
    switch (dbt) {
        case DBT::postgresql:
            *sql = "ALTER SEQUENCE " + sequence + " OWNED BY " + tableName +
                "." + columnName + ";";
            return;
        case DBT::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

const char* DBType::dbType() const
{
    switch (dbt) {
        case DBT::postgresql:
            return "PostgreSQL";
        case DBT::redshift:
            return "Redshift";
        default:
            return "(unknown)";
    }
}

static void encodeStr(const char* str, string* newstr, bool e)
{
    if (e)
        *newstr = "E'";
    else
        *newstr = '\'';
    const char *p = str;
    char c;
    while ( (c=*p) != '\0') {
        switch (c) {
            case '\\':
                *newstr += "\\\\";
                break;
            case '\'':
                *newstr += "''";
                break;
            case '\b':
                *newstr += "\\b";
                break;
            case '\f':
                *newstr += "\\f";
                break;
            case '\n':
                *newstr += "\\n";
                break;
            case '\r':
                *newstr += "\\r";
                break;
            case '\t':
                *newstr += "\\t";
                break;
            default:
                *newstr += c;
        }
        p++;
    }
    *newstr += '\'';
}

void DBType::encodeStringConst(const char* str, string* newstr) const
{
    switch (dbt) {
        case DBT::postgresql:
            encodeStr(str, newstr, true);
            break;
        case DBT::redshift:
            encodeStr(str, newstr, false);
            break;
        case DBT::unknown:
            *newstr = "(unknown)";
            break;
    }
}

void DBType::redshiftKeys(const char* distkey, const char* sortkey,
            string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            (*sql) = "";
            break;
        case DBT::redshift:
            (*sql) = string(" DISTKEY(") + distkey +
                string(") COMPOUND SORTKEY(") + sortkey + string(")");
            break;
        case DBT::unknown:
            (*sql) = "(unknown)";
            break;
    }
}



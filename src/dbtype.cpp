#include <stdexcept>

#include "dbtype.h"

DBType::DBType(etymon::odbc_conn* conn)
{
    string dbms_name;
    conn->get_dbms_name(&dbms_name);
    set_type(dbms_name);
}

void DBType::set_type(const string& dbms)
{
    if (dbms == "PostgreSQL") {
        dbt = DBT::postgresql;
    } else {
        if (dbms == "Redshift") {
            dbt = DBT::redshift;
        } else {
            string err = "Unknown database system: \"";
            err += dbms;
            err += "\"";
            throw runtime_error(err);
        }
    }
}

const char* DBType::jsonType() const
{
    switch (dbt) {
    case DBT::postgresql:
	return "JSON";
    case DBT::redshift:
	return "VARCHAR(65535)";
    default:
	return "(unknown)";
    }
}

const char* DBType::currentTimestamp() const
{
    switch (dbt) {
        case DBT::postgresql:
            return "CURRENT_TIMESTAMP";
        case DBT::redshift:
            return "SYSDATE";
        default:
            return "(unknown)";
    }
}

void DBType::renameSequence(const string& sequenceName,
        const string& newSequenceName, string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            *sql = "ALTER SEQUENCE IF EXISTS\n"
                "    " + sequenceName + "\n"
                "    RENAME TO " + newSequenceName + ";";
            return;
        case DBT::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void DBType::createSequence(const string& sequenceName, int64_t start,
        string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            *sql = "CREATE SEQUENCE " + sequenceName + "\n"
                "    START " + to_string(start) + ";";
            return;
        case DBT::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void DBType::autoIncrementType(int64_t start, bool namedSequence,
        const string& sequenceName, string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            if (namedSequence)
                *sql = "BIGINT NOT NULL\n"
                    "        DEFAULT\n"
                    "        nextval('" + sequenceName +
                    "')";
            else
                *sql = "BIGSERIAL";
            return;
        case DBT::redshift:
            *sql = "BIGINT GENERATED BY DEFAULT AS IDENTITY(" +
                to_string(start) + ", 1)";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void DBType::alterSequenceOwnedBy(const string& sequenceName,
        const string& tableColumnName, string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            *sql = "ALTER SEQUENCE " + sequenceName + "\n"
                "    OWNED BY " + tableColumnName + ";";
            return;
        case DBT::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

const char* DBType::dbType() const
{
    switch (dbt) {
        case DBT::postgresql:
            return "PostgreSQL";
        case DBT::redshift:
            return "Redshift";
        default:
            return "(unknown)";
    }
}

static void encodeStr(const char* str, string* newstr, bool e)
{
    if (e)
        *newstr = "E'";
    else
        *newstr = '\'';
    const char *p = str;
    char c;
    while ( (c=*p) != '\0') {
        switch (c) {
            case '\\':
                *newstr += "\\\\";
                break;
            case '\'':
                *newstr += "''";
                break;
            case '\b':
                *newstr += "\\b";
                break;
            case '\f':
                *newstr += "\\f";
                break;
            case '\n':
                *newstr += "\\n";
                break;
            case '\r':
                *newstr += "\\r";
                break;
            case '\t':
                *newstr += "\\t";
                break;
            default:
                *newstr += c;
        }
        p++;
    }
    *newstr += '\'';
}

void DBType::encodeStringConst(const char* str, string* newstr) const
{
    switch (dbt) {
        case DBT::postgresql:
            encodeStr(str, newstr, true);
            break;
        case DBT::redshift:
            encodeStr(str, newstr, false);
            break;
        case DBT::unknown:
            *newstr = "(unknown)";
            break;
    }
}

void DBType::redshiftKeys(const char* distkey, const char* sortkey,
            string* sql) const
{
    switch (dbt) {
        case DBT::postgresql:
            (*sql) = "";
            break;
        case DBT::redshift:
            (*sql) = string(" DISTKEY(") + distkey +
                string(") COMPOUND SORTKEY(") + sortkey + string(")");
            break;
        case DBT::unknown:
            (*sql) = "(unknown)";
            break;
    }
}


